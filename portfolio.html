<!doctype html>
	<html lang="en">
	  <head>
	    <meta charset="utf-8">
	    <title>Portfolio</title>
	  </head>
	  <body>
	    <style>
p {
    border: 5px solid rgb(37, 95, 255);
}
h2 {
	border: 5px solid rgb(255, 47, 62);
	font-size: 200%;
}
h3 {
	border: 5px solid rgb(255, 47, 62);
	font-size: 200%;
}
h4 {
	border: 5px solid rgb(255, 47, 62);
	font-size: 200%;
}
h5 {
	border: 5px solid rgb(255, 47, 62);
	font-size: 200%;
}
h6 {
	border: 5px solid rgb(255, 47, 62);
	font-size: 200%;
}
h7 {
    border: 5px solid rgb(255, 47, 62);
    font-size: 200%;
}
h8 {
    border: 5px solid rgb(255, 47, 62);
    font-size: 200%;
}
h9 {
    border: 5px solid rgb(255, 47, 62);
    font-size: 200%;
}
h10 {
    border: 5px solid rgb(255, 47, 62);
    font-size: 200%;
}
a:link, a:visited {
  background-color: lightblue;
  color: black;
  padding: 14px 25px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
}
a:hover, a:active {
 background-color: darkblue;
  color:white;
  box-shadow: 10px 10px 5px #888888;
} 


	   	      body {
	        background-color: lightpink;
}
</style>
    <a href="index.html">Home</a>
    <a href="aboutme.html">About Me</a>
    <h1>This is my Portfolio Page!</h1>
    <img src="images/portfolio(2).jpg" height="250">
    <img src="images/notebook.jpg" height="250">
    <img src="images/Lightbot.png" height="200">
     
     <h2>How Computing Changed Society (Reflection)</h2>
    <p>"Computing will transform society." That is a phrase that has been around since computers first started, but does it ring true?  The book Blown to Bits is about the computing and how it changes not just singular lives but the way we live as a society.  And like the title of this relections shows computing did change society.  One example of this is the fact that you can now download songs at the SAME quality as the original, and companies can’t do anything about it.  The amount of information put on the internet is so vast that by the time the courts issue a take down its been put up ten more times.  If someone’s favorite series gets taken off of Netflix or Hulu they can find it all online.  Computing changed the way that we view entertainment</p>
   <h3> Lightbot reflection</h3>
        <p>Light bot reflection
The computer game lightbot is a simple game about coding a little robot to light up blue tiles, this game was made by coders and because of that it accurately depicts what codings like.  You have to put in different inputs and you receive different outputs, you can even use loops to make your bot repeat.  But with that said it also isn’t like a computer because your goal is different.  In lightbot you only have to light up the tiles, whereas in real life you can have different goal, like making a light turn on or making a motor spin.
</p>
<h4>Pair Programing Questions</h4>
<p>1) Writing code in smaller pieces allows you to revise more easily and complete the coding in chunks without having to review massive amounts of coding, it leaves less room for error.</p>
<p>2) Building LEGO’s is a good example of figuring out a difficult problem when an error was made. Much like the program in coding when you build the LEGO creation you can make an error that you don’t notice until you’ve completed the creation. This forces you to backtrack to discover mistakes.</p>
<p>3) Our group thinks that the processors have multiple programs opened at once and cycles through the commands of each program in order and continues to do this at a fast pace giving the illusion that multiple programs are being ran at once.</p>
<iframe allowtransparency="true" width="485" height="402" src="//scratch.mit.edu/projects/embed/173318044/?autostart=false" frameborder="0" allowfullscreen></iframe>
<h5>Scratch Reflection</h5> 
<p> 1)	Using a program that uses hundred of sprites it is does not work that well if you have one button that goes to all of the sprites.  It is better to have one sprite per one button (much like a function), because it will activate much faster.  With multiple sprites the program has to take the time to run each sprites whereas one button will do it instantly.</p>
<p>2)	I think that events and handlers are something that calls back and handles inputs.  Within different structures you can use events as keywords and other such things.</p>
<p>3)	a)	Some methods in the play playG() key that are encapsulated is how G only does one thing.  One example of this is how I made a button that does the exact same thing that C does except it has a different sprite. 
	  b)	I think that it would've been convenient if the programmer put in a different variation of playG() like making one key use both the drum and sax or drum and tia.  Even though you’re not supposed to do that I think it would be an interesting way to use it.  </p>
<iframe allowtransparency="true" width="485" height="402" src="//scratch.mit.edu/projects/embed/172451177/?autostart=false" frameborder="0" allowfullscreen></iframe>
<h5>1.1.5 Reflection</h5>
<p>1)	The primary advantage of using a fixed variable is that it will make changing your code a lot easier.  If you have a code that has a bunch of set numbers it is better to have a variable if you want to change the numbers, instead of having to go through the whole code.</p>
<p>2) 	(Pseudo Code)	If Trash full
					Take trash out
				Else wait until parents yell at you</p>
<p>3)	Two examples of an accumulator variable are scoreboards and a cash register that counts customers.  The scoreboard will go up every time some scores and it will keep going up until the end of the game.  While a cash register can count how many people go to the store and buy something.</p>
<p>4)	The accumulator role is to count different objects and keep them, whereas an aggregator will add everything together such as how many times a mouse is clicked or how many times a goal is scored.</p>
      <iframe allowtransparency="true" width="485" height="402" src="//scratch.mit.edu/projects/embed/173645854/?autostart=false" frameborder="0" allowfullscreen></iframe>
      <h6>1.1.6 Reflection</h6>
<p>A Stepper is a variable that will go through different iterations of numbers i.e. 1, 3, 5, 7.  It can go through common patterns.  A Walker is a variable that can refer to members of a collection during iteration.  A Best-So-Far variable is a variable that can record the best/worst set of numbers.  It goes through the list and picks out the best or worst option, depending on the settings.</p>	     
<p>You can use a Best-So-Far to try and figure out the best test score on a test in a class.  You can also use it to see a leaderboard in an arcade game.</p>
 <iframe allowtransparency="true" width="485" height="402" src="//scratch.mit.edu/projects/embed/173800568/?autostart=false" frameborder="0" allowfullscreen></iframe>
 
 <h7>Scratch Written Review</h7>
<p>Our scratch game was that Sonic had to run around and grab the 15 dragon balls, while an unknown entity blasted you with blue fireballs.  The program was written in scratch and only has 3 sprites.  We made it so that every time sonic gets a dragonball a clone of the sprite is made and the sprites increase speed.  Once sonic gets 15 dragon balls the game is over.  The video used shows different attributes to the game.  One example is how if you press space bar you go faster (like sonic would), and other is that the dragon ball will move to a random position if touched.  These different attributes listed above are a part of what makes our game a whole.
</p>
<a href=https://scratch.mit.edu/projects/175444530/>Caleb and Zach's Scratch Game!</a>
        <!-- embedded video -->
	  <video controls>
    <source src="files/Scratchproject.mp4" type="video/mp4">
    Your browser does not support the video tag.
    </video>
    <iframe allowtransparency="true" width="485" height="402" src="//scratch.mit.edu/projects/embed/175444530/?autostart=false" frameborder="0" allowfullscreen></iframe>
		
	
	<h8>1.2.2 Introducing App Inventor</h8>
        <p>1)	App inventor is similar to Scratch in the sense that they both use a block system that is easy to pick up and play with.  One piece of the program not shown in Scratch that is shown in app inventor is the different sensors.  Scratch is not able to use sensors on your phone, whereas app inventor is able to.  The sensors are shown on the design side of the code (different from the blocks).</p>
        <p>2)	Mobile devices and their accessibility to everyone will make it so that many more people are able to make apps that no one has thought of.  Because of this there is so much information being pushed out at once that it is hard to try and access it all.  This new information age is making it so that anyone can make an app when ever they want.</p>
     <h9>1.2.3 Response</h9>
         <p>1)	App Inventor is similar to Scratch in the sense that it is easy to pick up and code.  They both come from MIT and use a similar block structure of coding, it helps introduce new people to their program easily.  It is different from scratch in the sense that you cannot update it live like you could in scratch.  If you want to view the effects you must update the emulator or download the app a bunch.</p>
         <p>2)	Design for a mobile device is different from the design of a desktop or laptop because, you have to condense a lot of what is displayed on the screen.  You also have to make it touch accessible with multiple commands like swiping, pinching, and sliding.  You must also make it so that the keyboard will not take up the whole screen whereas on a laptop it comes with a computer </p>
         <a href=https://drive.google.com/file/d/0B8aKjPFLwDnoV3phSi1oZTAxZ1E/view?usp=sharing> Caleb and Austins Google Draw!</a>
         <a href=https://repl.it/Mv7K/4> Easy Mode for Python Game!</a>
         <a href=https://repl.it/MnN2/11> Hard Mode for Python Game, For a real Challenge!</a> 
     <h10>1.3.3 Response</h10>
         <p>1)    The relationship between a colon and an if statement is that the colon is used to declare an indented block of code, i.e.(print “Hello World”).</p>
         <p>2)    The Boolean Operators that we have learned of are: and, or, ==, !=, <, >, <=, >=.  The one we haven’t learned about is the Logical XOR or ^ which stands for exclusive or.</p>
         <p>3)    Ira is right when she says that putting the code together will speed it up because it does not have to sift through repeated code.  Jayla is also correct when she says that wanting to change it, you’ll have to change it in two places, slowing down the time to run the code.  Kendra is wrong because it would not take more memory if it was on two separate lines. </p>     
     <h11>1.3.8 Response</h11>
         <p>1)    When a list is nearly sorted the fastest sorting algorithm is the insertion algorithm.  The insertion algorithm is used as a recursive base and that helps make it sort the nearly sorted fastest.</p>
         <p>2)    The merge sorter ends at the same time every time, with it’s only alteration being the size of the data used.  If the size is 20 then all 20’s will end on the same time, it is the same with 30 and 40 and 50.</p>
         <p>3)    The maximum number of guesses needed to guarantee a right answer is 9.  You take 366 and keep dividing it by 2.  This only works for actually educated guesses.</p>
         <p>4)    An unsorted list in a binary search is hard because up/down have no correlation to actual values making it more difficult to accurately search for the information.</p>
         <p>5)    The way to tell that Google keeps an inventory of webpage content sorted is by how fast it is pulled up.  You have millions of responses getting brought in fractions of seconds and with that shows that the get the content you want fastest you must have it sorted.  </p>
     <h12>1.3.10 Response</h12>
         <p>1)    One situation where you have to make predictions based on other people’s guesses is when you and a person come face to face.  You do want to get around so maybe you take a step left and they accidentally do the same, you must try to predict which way they will go in order to get around.  Simulations have been able to successfully impact social sciences by predicting human behaviour and other aspects to life.  Personally I believe that this will make society easier to understand and then easier to predict, which I think is a good thing. </p>
         <p>2)    Abstraction is used to condense whole sections of code into less complex and easier to understand functions.  It allows you to break up the complexity of code and have a clear flow-control between components.  It is useful in code because it allows you to put less code in and use the said function the original code is in (i.e. x =+ 1, return x, all into the x.count).</p>
         <p>3)    Abstraction in code helps to make the complexity of the code easier to understand.  One example of this is a function counting up the total, instead of having to constantly write a counting function you can just refer to .count.  The .count will now shortcut all the previous steps that you had to type before, in the prisoner's dilemma code I did not have to write a function counting how many times they betrayed, instead I used their_history.count(‘b’) to do it for me.</p>
     </body>
	</html>
